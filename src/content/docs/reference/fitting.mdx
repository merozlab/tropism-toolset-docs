---
title: Fitting Module API
description: API reference for curve fitting and model analysis functions.
---
import Equation from '../../../components/Equation.astro';

Functions for fitting mathematical models to plant data, including linear, piecewise, exponential, and logistic models, plus steady state detection.

## Convergence Length Fitting

### `fit_Lc()`

Fit piecewise constant + saturating exponential to extract convergence length.

**Signature:**
```python
fit_Lc(
    data: pd.DataFrame,
    *,
    rotate: Optional[str] = None,
    initial_guess: Optional[List[Optional[float]]] = None,
    bounds: Optional[Tuple[list, list]] = None,
    crop_start: int = 0,
    crop_end: int = 0,
    display: bool = False,
    save_path: str | Path | None = None,
) -> Tuple[float, float, float, float, float]
```

**Parameters:**
- `data` (pd.DataFrame): Full DataFrame in either x,y or s,theta format containing centerline data. To rotate, the data must include the initial frame.
- `rotate` (str or None, optional): Rotation option: "horizontal", "vertical", or None for no rotation. Default: None
- `initial_guess` (list, optional): Initial parameters [x0, Bl, A, Lc]. Can contain None values for auto-estimation.
- `bounds` (tuple, optional): Parameter bounds for curve fitting
- `crop_start` (int, optional): Number of points to crop from beginning. Default: 0
- `crop_end` (int, optional): Number of points to crop from end. Default: 0
- `display` (bool, optional): Display fit plot inline. Default: False
- `save_path` (str | Path | None, optional): Save plot to path

**Returns:**
- `tuple[float, float, float, float, float]`: (x0, Bl, A, Lc, r_squared)
  - `x0`: Transition point between constant and exponential regions
  - `Bl`: Baseline value (constant before x0, asymptote after)
  - `A`: Amplitude of exponential change
  - `Lc`: Convergence length (characteristic length scale)
  - `r_squared`: R² value of fit

**Model:**
<Equation>

$$
\theta(s) = \begin{cases}
B_\ell & s < s_0 \\ B_\ell + A(1 - e^{-(s-s_0)/L_c}) & s \geq s_0
\end{cases}
$$

</Equation>

**Example:**
```python
from tropism_toolset import fit_Lc

# Fit using full DataFrame (can be in x,y or s,theta format)
# Function will automatically use the last frame for fitting
x0, Bl, A, Lc, r_squared = fit_Lc(
    data,
    rotate="horizontal",  # Optional: rotate to horizontal
    display=True,
    crop_end=3  # Remove noisy tip points
)

print(f"Convergence length: {Lc:.4f} m")
print(f"R²: {r_squared:.4f}")
```

**Notes:**
- Accepts DataFrame in either x,y or s,theta format
- Automatically uses the last (steady-state) frame for fitting
- If `rotate` is specified, the data must include the initial frame for rotation calculation

---

## Linear Fitting

### `fit_linear()`

Fit single linear function to data.

**Signature:**
```python
fit_linear(
    x: pd.Series,
    y: pd.Series,
    title: str = "Linear Fit",
    slope_label: str | None = None,
    display: bool = False,
    save_path: str | Path | None = None,
) -> Tuple[float, float, np.ndarray]
```

**Parameters:**
- `x` (pd.Series): Time/frame values (x-axis)
- `y` (pd.Series): Values to fit (y-axis)
- `title` (str, optional): Plot title. Default: "Linear Fit"
- `slope_label` (str | None, optional): Label for slope annotation
- `display` (bool, optional): Display plot. Default: False
- `save_path` (str | Path | None, optional): Save plot to path.

**Returns:**
- `tuple[float, float, np.ndarray]`: (slope, r_squared, coeffs)
  - `slope`: Slope of linear fit
  - `r_squared`: R² value
  - `coeffs`: Polynomial coefficients [slope, intercept]

**Example:**
```python
from tropism_toolset.fitting import fit_linear

# Fit growth rate
slope, r2, coeffs = fit_linear(
    frames,
    lengths,
    display=True,
    slope_label="growth rate"
)
```

---

### `fit_piecewise_linear()`

Fit two linear segments with breakpoint optimization via R² maximization.

**Signature:**
```python
fit_piecewise_linear(
    frames: np.ndarray,
    values: np.ndarray,
    min_bp: int = 5
) -> Tuple[float, float, int, Tuple[np.ndarray, np.ndarray]]
```

**Parameters:**
- `frames` (np.ndarray): Frame numbers (x-axis)
- `values` (np.ndarray): Values to fit (y-axis)
- `min_bp` (int, optional): Minimum frames from start/end for breakpoint. Default: 5

**Returns:**
- `tuple[float, float, int, tuple]`: (slope1, slope2, breakpoint, (p1_coeffs, p2_coeffs))
  - `slope1`: Phase 1 slope
  - `slope2`: Phase 2 slope
  - `breakpoint`: Optimal frame index for transition
  - `p1_coeffs`: Phase 1 coefficients [slope, intercept]
  - `p2_coeffs`: Phase 2 coefficients [slope, intercept]


---

### `fit_piecewise_linear_continuous()`

Fit two continuous linear segments to data using curve_fit, with breakpoint x₀ as a fitted parameter.

**Signature:**
```python
fit_piecewise_linear_continuous(
    times: pd.Series,
    values: pd.Series,
    initial_guess: Optional[list] = None,
    bounds: Optional[Tuple[list, list]] = None,
    display: bool = False,
    save_path: str | Path | None = None,
) -> Tuple[float, float, float, Tuple[np.ndarray, np.ndarray]]
```

**Parameters:**
- `times` (pd.Series): Time/frame values
- `values` (pd.Series): Values to fit
- `initial_guess` (list, optional): Initial parameters [x0, m1, b1, m2]
- `bounds` (tuple, optional): Parameter bounds
- `display` (bool, optional): Display plot. Default: False
- `save_path` (str | Path | None, optional): Save plot to path.

**Returns:**
- `tuple[float, float, float, tuple]`: (slope1, slope2, breakpoint, (p1_coeffs, p2_coeffs))
  - `slope1`: Phase 1 slope
  - `slope2`: Phase 2 slope
  - `breakpoint`: Optimal breakpoint location (continuous)
  - `p1_coeffs`: Phase 1 coefficients
  - `p2_coeffs`: Phase 2 coefficients

**Model:**
<Equation>
$$
 y = \begin{cases}
 m_1 x + b_1 & x < x_0 \\
 m_2(x - x_0) + (m_1 x_0 + b_1) & x \geq x_0
 \end{cases}
$$
</Equation>

**Notes:**
- Breakpoint x₀ is optimized as continuous parameter
- Enforces continuity at breakpoint
- More flexible than discrete breakpoint search
- Used by `fit_angular_velocity()`


---

## Nonlinear Fitting

### `fit_saturating_exponential()`

Fit saturating exponential model for approach to steady state.

**Signature:**
```python
fit_saturating_exponential(
    x: pd.Series,
    y: pd.Series,
    initial_guess: Optional[list] = None,
    bounds: Optional[Tuple[list, list]] = None,
    display: bool = False,
    save_path: str | Path | None = None,
) -> Tuple[float, float, float, float]
```

**Parameters:**
- `x` (pd.Series): Time/frame values
- `y` (pd.Series): Angle or length measurements
- `initial_guess` (list, optional): Initial parameters [y_inf, y_0, tau]
- `bounds` (tuple, optional): Parameter bounds
- `display` (bool, optional): Display plot. Default: False
- `save_path` (str | Path | None, optional): Save plot to path.

**Returns:**
- `tuple[float, float, float, float]`: (y_inf, y_0, tau, r_squared)
  - `y_inf`: Steady-state value
  - `y_0`: Initial value
  - `tau`: Time constant in frames
  - `r_squared`: R² value

**Model:**
<Equation>

$$y(t) = y_\infty - (y_\infty - y_0)e^{-t/\tau}$$

</Equation>

Initial rate:
<Equation>

$$\frac{dy}{dt}\Big|_{t=0} = \frac{y_\infty - y_0}{\tau}$$

</Equation>

**Example:**
```python
from tropism_toolset.fitting import fit_saturating_exponential

# Fit angle approach to steady state
theta_inf, theta_0, tau, r2 = fit_saturating_exponential(
    frames,
    tip_angles,
    display=True
)

print(f"Steady-state angle: {theta_inf:.6f} rad")
print(f"Time constant: {tau:.2f} frames")
```

---

## Steady State Detection

### `find_steady_state()`

Find steady state start in time series data.

**Signature:**
```python
find_steady_state(
    data: pd.Series,
    window: int = 30,
    mean_tol: float = 0.001,
    var_tol: float = 0.0001
) -> int | None
```

**Parameters:**
- `data` (pd.Series): Time series data to analyze
- `window` (int, optional): Sliding window size. Default: 30
- `mean_tol` (float, optional): Mean change tolerance. Default: 0.001
- `var_tol` (float, optional): Variance change tolerance. Default: 0.0001

**Returns:**
- `int` or `None`: Frame number where steady state begins, or None if not found

**Example:**
```python
from tropism_toolset.fitting import find_steady_state
from tropism_toolset import get_lengths_from_centerlines

# Get length time series
lengths_df = get_lengths_from_centerlines(data)
lengths = lengths_df['length (m)']

# Find when growth stabilizes
Tc = find_steady_state(
    lengths,
    window=30,
    mean_tol=0.0005,
    var_tol=0.00001
)

if Tc is not None:
    print(f"Steady state reached at frame {Tc}")
else:
    print("Steady state not detected")
```


---

### `find_steady_state_from_masks()`

Detect steady state from mask stability analysis.

**Signature:**
```python
find_steady_state_from_masks(
    mask_dir: str | Path,
    px_per_m: float,
    window: int = 15,
    mean_tol: float | None = None,
    var_tol: float = 0.00001,
    method: str = "edge_change",
    display: bool = False,
    save_path: str | Path | None = None,
) -> Tuple[pd.Series, int | None, float | None]
```

**Parameters:**
- `mask_dir` (str or Path): Directory with mask files (*.bmp)
- `px_per_m` (float): Pixel to meter conversion factor
- `window` (int, optional): Window size for detection. Default: 15
- `mean_tol` (float | None, optional): Mean tolerance (auto-calculated if None)
- `var_tol` (float, optional): Variance tolerance. Default: 0.00001
- `method` (str, optional): 'overlap' or 'edge_change'. Default: 'edge_change'
- `display` (bool, optional): Display plot. Default: False
- `save_path` (str | Path | None, optional): Save plot to path.

**Returns:**
- `tuple[pd.Series, int | None, float | None]`: (stability_scores, Tc, median_area)
  - `stability_scores`: Instability scores between frames
  - `Tc`: Steady state start frame, or None
  - `median_area`: Median mask area in m²

**Methods:**
- **'overlap'**: Jaccard Index (Intersection over Union) - measures mask overlap
- **'edge_change'**: Edge pixel changes - measures boundary changes

**Example:**
```python
from tropism_toolset.fitting import find_steady_state_from_masks

scores, Tc, area = find_steady_state_from_masks(
    mask_dir='data/masks/',
    px_per_m=10000,  # 0.1 mm per pixel
    method='edge_change',
    display=True
)

if Tc is not None:
    print(f"Steady state at frame {Tc}")
    print(f"Median mask area: {area:.6f} m²")
```

## Smoothing

### `smooth_centerlines()`

Apply Savitzky-Golay smoothing to centerline coordinates frame-by-frame.

**Signature:**
```python
smooth_centerlines(
    data: pd.DataFrame,
    window_length: int = 5,
    polyorder: int = 2,
) -> pd.DataFrame
```

**Parameters:**
- `data` (pd.DataFrame): DataFrame with columns ['frame', 'x', 'y']
- `window_length` (int, optional): Length of smoothing window. Default: 5
- `polyorder` (int, optional): Polynomial order. Default: 2

**Returns:**
- `pd.DataFrame`: Smoothed DataFrame

## See Also

- [Constants API](/reference/constants/) - For using fitted parameters (Lc, γ, β)
- [Geometric Calculations API](/reference/geometric-calculations/) - For angle and length calculations
- [Visualization API](/reference/visualization/) - For plotting fitted models
- [Constants Extraction Guide](/guides/constants-extraction/) - Usage examples
- [Steady State Guide](/guides/steady-state/) - Detection strategies