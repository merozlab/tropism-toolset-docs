---
title: Extracting Physical Constants
description: Extract convergence length, gamma, beta, and other physical parameters from your data.
---
import Equation from '../../../components/Equation.astro';

Learn how to extract the key physical constants that characterize plant tropism responses.

## Overview of Constants

The toolkit extracts three primary constants:

| Constant | Symbol | Units | Meaning |
|----------|--------|-------|---------|
| Convergence Length | $L_c$ | m | Spatial scale of gravitropic response |
| Proprioceptive Sensitivity | $\gamma$ | s⁻¹ | Rate of curvature correction |
| Gravitropic Sensitivity | $\beta$ | m⁻¹ | Spatial sensitivity to gravity |

These are related by: $\beta = \gamma / L_c$

## Extracting Convergence Length (Lc)

The convergence length is extracted by fitting a saturating exponential to angle vs. arc-length data.

### Basic Usage

```python
from constants import fit_Lc, get_angles, get_arclengths
import pandas as pd

# Load data and get final frame (at steady state)
data = pd.read_csv("centerlines.csv")
final_frame = data['frame'].max()
frame_data = data[data['frame'] == final_frame]

# Calculate angles and arc lengths
angles = get_angles(frame_data)
arclengths = get_arclengths(frame_data) / 100  # Convert pixels to meters

# Fit Lc
x0, Bl, A, Lc, r_squared = fit_Lc(
    arclengths,
    angles,
    show=True,
    crop_start=0,
    crop_end=3
)

print(f"Convergence Length: {Lc:.4f} m")
print(f"R²: {r_squared:.4f}")
```

### The Fitted Model

The function fits a piecewise saturating exponential:

<Equation>

$$
\theta(s) = \begin{cases}
B_\ell & s < s_0 \\
B_\ell + A(1 - e^{-(s-s_0)/L_c}) & s \geq s_0
\end{cases}
$$

</Equation>

Where:
- $s_0$ (`x0`): Transition point (start of growth zone)
- $B_\ell$ (`Bl`): Baseline angle
- $A$ (`A`): Amplitude of response
- $L_c$ (`Lc`): Convergence length

### Customizing the Fit

#### Initial Guess

Provide starting values for the optimization:

```python
# Parameter order: [x0, Bl, A, Lc]
initial_guess = [0.01, 0.0, 1.5, 0.05]

x0, Bl, A, Lc, r_squared = fit_Lc(
    arclengths,
    angles,
    initial_guess=initial_guess,
    show=True
)
```

#### Parameter Bounds

Constrain the fit with bounds:

```python
# Bounds: ([lower bounds], [upper bounds])
bounds = (
    [0.0, -np.pi/2, 0.0, 0.01],  # Lower bounds
    [0.1, np.pi/2, np.pi, 0.20]   # Upper bounds
)

x0, Bl, A, Lc, r_squared = fit_Lc(
    arclengths,
    angles,
    bounds=bounds,
    show=True
)
```

#### Cropping Noisy Regions

Remove noisy points at the extremities:

```python
# Crop 5 points from start, 10 from end
x0, Bl, A, Lc, r_squared = fit_Lc(
    arclengths,
    angles,
    crop_start=5,
    crop_end=10,
    show=True
)
```

### Assessing Fit Quality

A good fit should have:
- **R² > 0.95**: High quality
- **R² 0.90-0.95**: Acceptable
- **R² < 0.90**: Poor fit, check data quality

```python
if r_squared > 0.95:
    print("✓ Excellent fit quality")
elif r_squared > 0.90:
    print("⚠ Acceptable fit, but review visually")
else:
    print("✗ Poor fit - check data quality or adjust parameters")
```

## Calculating Gamma (γ)

Gamma represents proprioceptive sensitivity and is calculated from the time to steady state.

### Method 1: From Steady State Time

```python
from constants import get_gamma

# Parameters
Tc = 120  # Frame at which steady state begins
minutes_per_frame = 15
period = minutes_per_frame * 60  # Convert to seconds

# Calculate gamma
gamma = get_gamma(Tc, period)

print(f"Gamma: {gamma:.6f} s⁻¹")
print(f"Characteristic time: {1/gamma:.2f} s")
print(f"Characteristic time: {1/gamma/3600:.2f} hours")
```

### Method 2: From Threshold Crossing

For more precise calculations:

```python
from constants import get_gamma_2

Tc_frames = 120
frame_interval_s = 15 * 60

# Using completion fraction p
gamma = get_gamma_2(
    Tc_frames,
    frame_interval_s,
    p=0.632  # 1 - 1/e (one time constant)
)

# Or using initial and threshold values
S0 = 1.5  # Initial signal
eps = 0.1  # Threshold value
gamma = get_gamma_2(
    Tc_frames,
    frame_interval_s,
    S0=S0,
    eps=eps
)

print(f"Gamma (precise): {gamma:.6f} s⁻¹")
```

### Determining Tc

See [Steady State Detection](/guides/steady-state/) for methods to find Tc automatically.

## Calculating Beta (β)

Beta is the spatial gravitropic sensitivity:

```python
from constants import get_beta

beta = get_beta(Lc, gamma)

print(f"Beta: {beta:.4f} m⁻¹")
print(f"1/Beta: {1/beta:.4f} m (characteristic length)")
```

### Physical Interpretation

- High $\beta$: Strong gravitropic response per unit length
- Low $\beta$: Weak gravitropic response
- $1/\beta$ gives another characteristic length scale

## Complete Extraction Workflow

```python
from constants import (
    get_angles, get_arclengths, fit_Lc,
    get_gamma, get_beta, find_steady_state
)
import pandas as pd

# Configuration
px_to_m = 100
minutes_per_frame = 15
period = minutes_per_frame * 60

# Load data
data = pd.read_csv("experiment_centerlines.csv")

# Find steady state automatically
lengths_over_time = []
for frame in data['frame'].unique():
    frame_data = data[data['frame'] == frame]
    arclengths = get_arclengths(frame_data) / px_to_m  # Convert to meters
    lengths_over_time.append(arclengths[-1])

Tc, smoothed_data = find_steady_state(
    np.array(lengths_over_time),
    threshold_factor=0.15,
    min_steady_duration=20,
    show=True
)

if Tc is None:
    print("⚠ No steady state detected, using manual value")
    Tc = 120

# Extract Lc from final frame
final_frame = data['frame'].max()
frame_data = data[data['frame'] == final_frame]
angles = get_angles(frame_data)
arclengths = get_arclengths(frame_data) / px_to_m  # Convert to meters

x0, Bl, A, Lc, r_squared = fit_Lc(
    arclengths, angles,
    show=True,
    crop_end=3
)

# Calculate gamma and beta
gamma = get_gamma(Tc, period)
beta = get_beta(Lc, gamma)

# Print comprehensive results
print("\n" + "="*60)
print("PHYSICAL CONSTANTS SUMMARY")
print("="*60)
print(f"Convergence Length (Lc):           {Lc:.4f} m")
print(f"Proprioceptive Sensitivity (γ):    {gamma:.6f} s⁻¹")
print(f"Gravitropic Sensitivity (β):       {beta:.4f} m⁻¹")
print(f"Characteristic Time (1/γ):         {1/gamma:.2f} s = {1/gamma/3600:.2f} h")
print(f"Characteristic Length (1/β):       {1/beta:.4f} m")
print(f"Steady State Frame (Tc):           {Tc}")
print(f"Fit Quality (R²):                  {r_squared:.4f}")
print(f"Transition Point (x₀):             {x0:.4f} m")
print(f"Baseline Angle (Bℓ):              {Bl:.4f} rad = {np.degrees(Bl):.2f}°")
print(f"Amplitude (A):                     {A:.4f} rad = {np.degrees(A):.2f}°")
print("="*60)
```

## Batch Processing Multiple Experiments

Extract constants from multiple experiments:

```python
import glob
from pathlib import Path

experiments = glob.glob("data/*_centerlines.csv")
results = {}

for exp_file in experiments:
    exp_name = Path(exp_file).stem
    print(f"\nProcessing: {exp_name}")

    try:
        # Load and analyze
        data = pd.read_csv(exp_file)
        final_frame = data['frame'].max()
        frame_data = data[data['frame'] == final_frame]

        angles = get_angles(frame_data)
        arclengths = get_arclengths(frame_data) / px_to_m  # Convert to meters
        x0, Bl, A, Lc, r_squared = fit_Lc(arclengths, angles, show=False)

        # Store results
        results[exp_name] = {
            'Lc': Lc,
            'r_squared': r_squared,
            'x0': x0,
            'Bl': Bl,
            'A': A
        }

    except Exception as e:
        print(f"  ✗ Failed: {e}")
        continue

# Create summary DataFrame
import pandas as pd
summary = pd.DataFrame(results).T
print("\n" + summary.to_string())

# Save results
summary.to_csv("batch_constants_results.csv")
```

## Validating Results

### Check Against Expected Ranges

```python
# Typical ranges for roots
expected_ranges = {
    'Lc': (0.01, 0.15),      # m
    'gamma': (1e-5, 1e-3),   # s⁻¹
    'beta': (0.1, 100),      # m⁻¹
}

def validate_constant(name, value, expected_range):
    low, high = expected_range
    if low <= value <= high:
        print(f"✓ {name} = {value:.6f} is within expected range")
    else:
        print(f"⚠ {name} = {value:.6f} is OUTSIDE expected range [{low}, {high}]")

validate_constant('Lc', Lc, expected_ranges['Lc'])
validate_constant('gamma', gamma, expected_ranges['gamma'])
validate_constant('beta', beta, expected_ranges['beta'])
```

### Compare with Literature

```python
# Example literature values (Bastien et al., 2014)
lit_Lc = 0.042  # m
lit_gamma = 2.3e-4  # s⁻¹

print("\nComparison with Literature:")
print(f"Lc:    {Lc:.4f} m (literature: {lit_Lc:.4f} m)")
print(f"Gamma: {gamma:.6f} s⁻¹ (literature: {lit_gamma:.6f} s⁻¹)")
print(f"Ratio Lc:    {Lc/lit_Lc:.2f}x")
print(f"Ratio Gamma: {gamma/lit_gamma:.2f}x")
```

## Troubleshooting Poor Fits

### Issue: Low R² value

**Solutions:**
1. Increase `crop_end` to remove noisy tip region
2. Smooth data before fitting
3. Check that you're using steady-state frame
4. Verify calibration (px_to_m) is correct

### Issue: Unrealistic Lc values

**Solutions:**
1. Provide better initial guess based on visual inspection
2. Add parameter bounds to constrain optimization
3. Check for data quality issues (gaps, discontinuities)

### Issue: Fit doesn't converge

**Solutions:**
```python
# Try different initial guesses
guesses = [
    [0.01, 0.0, 1.0, 0.03],
    [0.02, 0.1, 1.5, 0.05],
    [0.005, -0.1, 2.0, 0.08]
]

for i, guess in enumerate(guesses):
    try:
        x0, Bl, A, Lc, r_squared = fit_Lc(arclengths, angles, initial_guess=guess)
        print(f"Guess {i}: Lc={Lc:.4f}, R²={r_squared:.4f}")
    except:
        print(f"Guess {i}: Failed")
```

## Next Steps

- Learn about [Growth Analysis](/guides/growth-analysis/) to extract temporal dynamics
- Explore [Mathematical Models](/guides/models/chauvet/) to understand the theory
- Use [Batch Processing](/advanced/batch-processing/) for multiple experiments
